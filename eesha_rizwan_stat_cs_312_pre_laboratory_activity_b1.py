# -*- coding: utf-8 -*-
"""Eesha Rizwan - STAT/CS 312 - Pre-Laboratory Activity B1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YArOeX0AkXpEj3VsOgOarTJ8BVb32xVy

<p style="text-align:center; font-size:50px; padding: 1em 0;"> üêâ </p>

# &nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;
&nbsp;


# Laboratory Lecture B-1 #

Our second laboratory activity covers the material in Chapter 2. This includes focusing on the data especially getting the data in the right form and measuring similarity. Again, remember that this is what I talk about during class. The actual laboratory activity that you do is on the course website.

&nbsp;
&nbsp;
&nbsp;

## Preamble ##

In this section, you import all of the necessary packages for the notebook.
"""

import math
import io
import os

import numpy as np
import pandas as pd
import scipy.stats as ss
import seaborn as sns
import matplotlib.pyplot as plt

"""## Data ##

Here, we will load two work sheets and combine them using Python.
"""

### Note
#   If you are using Google Colab, the following cell is needed. It connects this notebook
#   to your Google Drive. If you are using Jupyter notebooks, then this cell is (probably)
#   not needed. You just need to ensure that the xlsx file is in the folder.


from google.colab import drive
drive.mount('/content/drive', force_remount=True)

pathname = "/content/drive/My Drive/STAT 312/Laboratory Activity B/"
os.chdir(pathname)

filename = "RuralAtlasData24.xlsx"
dtJ = pd.read_excel(filename, sheet_name="Income")
dtC = pd.read_excel(filename, sheet_name="County Classifications")

dtC = dtC.rename(columns = {"FIPStxt": "FIPS"})
dtC

dt = pd.merge(dtJ,dtC,  on='FIPS')

dt

print( dtJ.shape )
print( dtC.shape )
print( dt.shape )

dt

dtK = dt[dt['State_x'] !="PR"]
dtK
dt = dtK.loc[ dtK["FIPS"]/1000!=round(dtK["FIPS"]/1000) ]
dt=dt.dropna()
dt

median_household_income= dt['Median_HH_Inc_ACS']
major_urban_center= dt['UrbanInfluenceCode2013']

mod=ss.linregress(major_urban_center, median_household_income)
mod

plt.figure(figsize=(10, 6))

plt.scatter(major_urban_center, median_household_income)
plt.plot(major_urban_center, mod.intercept + mod.slope*major_urban_center, 'r', label= 'OLS Line')
plt.title('Scatter Plot: Urban Influence vs. Median Household Income')
plt.xlabel('Major Urban Center')
plt.ylabel('Median Household Income')
plt.legend()
plt.show()

z= mod.slope *5 + mod.intercept
print (z)

knox_county = dt[dt['County_x']=="Knox"]
knox_county = knox_county[knox_county['UrbanInfluenceCode2013']==5]
k = knox_county.Median_HH_Inc_ACS
print(k)

def minkowski_distance(vector1,vector2, r):
  print(sum(abs(v1 - v2) ** r for v1, v2 in zip(vector1, vector2)) ** (1 / r))

def hamming_distance(vector1,vector2):
  print(sum(v1 != v2 for v1, v2 in zip(vector1, vector2)))

importantMeasures = dt.loc[:, ["Metro_Adjacent2013", "Micropolitan2013", "Type_2015_Farming_NO","Type_2015_Manufacturing_NO"] ]
importantMeasures

print( dt[dt["County_x"]=="Knox"].head(5) )

print( dt[dt["County_x"]=="Warren"].head(5) )

hamming_distance( importantMeasures.iloc[648] , importantMeasures.iloc[694] )

print( dt[dt["County_x"]=="Fulton"].head(5) )

hamming_distance( importantMeasures.iloc[648] , importantMeasures.iloc[629] )

minkowski_distance( importantMeasures.iloc[648] , importantMeasures.iloc[694] , 2)

minkowski_distance( importantMeasures.iloc[648] , importantMeasures.iloc[629] , 2)

def cos_similarity(a, b):
  return math.degrees(math.acos(np.dot(a,b)/(np.linalg.norm(a)*np.linalg.norm(b))))

cos_similarity( importantMeasures.iloc[648] , importantMeasures.iloc[694] )

cos_similarity( importantMeasures.iloc[648] , importantMeasures.iloc[629] )

cos_similarity( importantMeasures.iloc[694] , importantMeasures.iloc[629] )

def angle_difference(a,degrees):

  for x in importantMeasures.index:
    if (abs(cos_similarity(a,importantMeasures.iloc[x]) - degrees == 0)):
      return x
  return -1

angle_difference(importantMeasures.iloc[648],0)

print(dt.iloc[6])

print( dt[dt["County_x"]=="Butler"].head(5) )

def angle_difference2(a,degrees):

  for x in importantMeasures.index:
    if (abs(cos_similarity(a,importantMeasures.iloc[x]) - degrees == 90)):
      return x
  return -1

angle_difference(importantMeasures.iloc[648],90)

"""&nbsp;

&nbsp;

# The End #

This is the end of the lecture part of the lab. Please visit the website to see what the lab assignment is.

### Reference ###

```
@misc{RuralAtlasData23,
  title        = "Atlas of Rural and Small-Town {A}merica",
  author       = "{US Economic Research Service}",
  howpublished = "\url{https://www.ers.usda.gov/data-products/atlas-of-rural-and-small-town-america/download-the-data/}",
  year         = 2021,
  note         = "Accessed: 2021-06-08"
}
```
"""